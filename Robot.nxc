// Movement
#define MAX_DISTANCE_MS 0.31
#define DISTANCE_TIRES_MM 165

// Optic Sensor
#define THRESHOLD 40

// Event Constants
#define START_TURN_DISTANCE 20 // TODO: Satz des Pythagoras
#define END_DISTANCE 20 // TODO: Pythagoras
#define BALL_LOAD_DISTANCE 20 // TODO: Pythagoras
#define BALL_LOAD_WAITING_TIME 0 // TODO: Beladezeit rausfinden
#define OBSTACLE_CONTACT_DISTANCE 0 // TODO: Abstand fÃ¼r Schiebeaufgabe

// Dumping
#define DUMP_TIME 1
#define DUMP_SPEED 50

enum State {
	INIT,
	MOVE_1,
	GET,
	MOVE_2,
	PUSH,
	MOVE_3,
	MOVE_4,
	END
};
State current_state;
int whiteCount = 0;

sub turn_degrees(float degrees, int speed) {
	float signedSpeed = speed * (degrees / abs(degrees));
	OnFwd(OUT_A, signedSpeed);
	OnRev(OUT_B, signedSpeed);
	float distance = abs(PI * DISTANCE_TIRES_MM * (degrees / 360.0));
	float velocity = MAX_DISTANCE_MS * (speed / 100.0);
	int waitTime = distance / velocity;
	Wait(waitTime);
	Off(OUT_AB);
}

sub check_for_special_event() {
	if (SENSOR_1 > THRESHOLD && SENSOR_2 > THRESHOLD && SENSOR_3 > THRESHOLD && current_state == MOVE_2) {
		whiteCount++;
	}	else if (SENSOR_1 <= THRESHOLD && SENSOR_2 <= THRESHOLD && SENSOR_3 <= THRESHOLD && SensorUS(IN_4) < END_DISTANCE && current_state == MOVE_4) {
		current_state = END;
	}	else if (whiteCount == 3 && current_state == MOVE_2) {
		current_state = PUSH;
	}	else if (SensorUS(IN_4) < BALL_LOAD_DISTANCE && current_state == MOVE_1) {
		current_state = GET;
	} else if (current_state == MOVE_3 && SENSOR_1 <= THRESHOLD && SENSOR_2 <= THRESHOLD && SENSOR_3 <= THRESHOLD) {
		turn_degrees(90, 75); // TODO: This is inconsistent, use a dedicated state if enough time is left
		current_state = MOVE_4;
	}
}


sub turn_after_start() {
	if (SensorUS(IN_4) < START_TURN_DISTANCE && SENSOR_2 > THRESHOLD) {
		turn_degrees(200, 100);
		current_state = MOVE_1;
	}
}

sub dump() {
	Wait(500);
	Off(OUT_AB);
	OnFwd(OUT_C, DUMP_SPEED);
	Wait(DUMP_TIME * 1000);
	OnRev(OUT_C, DUMP_SPEED);
	Wait(DUMP_TIME * 1000);
	Off(OUT_C);
}

sub catch_ball() {
	Off(OUT_AB);
	Wait(BALL_LOAD_WAITING_TIME);
	current_state = MOVE_2;
}

sub push_obstacle() {
	turn_degrees(90, 75);
	while (SensorUS(IN_4) < OBSTACLE_CONTACT_DISTANCE) {
		OnRev(OUT_AB, 50);
		// Use move() or something
		Wait(10);
	}
	current_state = MOVE_3;
}

inline float get_turn_degrees() {
	if(SENSOR_1 < THRESHOLD) {
		if(SENSOR_2 < THRESHOLD) {
			if(SENSOR_3 < THRESHOLD) {
				return 0;
			} else {
				return -19;
			}
		} else {
			if(SENSOR_3 < THRESHOLD) {
				return 0;
			} else {
				return -19;
			}
		}
	} else {
		if(SENSOR_2 < THRESHOLD) {
			if(SENSOR_3 < THRESHOLD) {
				return 9;
			} else {
				return 0;
			}
		} else {
			if(SENSOR_3 < THRESHOLD) {
				return 19;
			} else {
				return 0;
			}
		}
	}
}

sub move() {
	float degrees = get_turn_degrees();
	turn_degrees(degrees, 80);
	OnRev(OUT_AB, 100);
	Wait(10);
}

sub run_special_event_if_available() {
	switch(current_state) {
		case INIT:
			turn_after_start();
		case GET:
			catch_ball();
			break;
		case PUSH:
			push_obstacle();
			break;
		case END:
			dump();
			Stop(true);
			break;
	}
}

sub init() {
	current_state = INIT;
	//Sensor 1 LEFT 2 MIDDLE 3 RIGHT
	SetSensorLight(IN_1);
	SetSensorLight(IN_2);
	SetSensorLight(IN_3);
	SetSensorLowspeed(IN_4);
}

task main() {
	init();
	while(true) {
		check_for_special_event();
		run_special_event_if_available();
		move();
	}
}
